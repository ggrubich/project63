class Parser
{
    string input;    // analizowany tekst
    size_t position; // bieżący znak
 
  public:
 
    Parser(string input);
    
    void skip_whitespace();
 
    char look_ahead();
 
    Expression* parse_Expression(); // wyrażenie
    Expression* parse_Constant();   // liczba
    Expression* parse_Variable();   // nazwa zmiennej
    Expression* parse_Section();    // blok
    Expression* parse_Bracket()     // nawias
    Expression* parse_String()      // napis
};

Expression* Parser::parse_Expression()
{
  Expression* e = parse_Constant();
  if (look_ahead() == EOS)
    return e;
  else
  {
    delete e;
    throw Not_parsed();
  }
}

Expression* Parser::parse_Constant()
{
  Expression* e = parse_Variable();
  if (look_ahead() == EOS)
    return e;
  else
  {
    delete e;
    throw Not_parsed();
  }
}


Expression* Parser::parse_Variable()
{
  string s;
  while (isalnum(input[position]))
  {
    s.push_back(input[position]);
    position++;
  }
  return new Variable(s);
}


Expression* Parser::parse_Section()
{
  Expression* e = NULL;
  //sprawdź nazwę zmiennej
  //sprawdź wyrażenie
  //sprawdź, czy są kolejne nawiasy
 
}



Expression* Parser::parse_String()
{
  Expression* e = NULL;
 
  try
  {
    // kod
  }
  catch (Not_parsed)
  {
    delete e;
    throw Not_parsed();
  }
 
  return e;
}

Expression* Parser::parse_Bracket()
{
position++;

  Expression* e = parse_string();
  if (look_ahead() == ')')
  {
    position++;
    return e;
  }
  else
  {
    delete e;
    throw Not_parsed();
  }
}
