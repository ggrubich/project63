class Parser
{
    string input;    // analizowany tekst
    size_t position; // bieżący znak
 
  public:
 
    Parser(string input);
    
    void skip_whitespace();
 
    char look_ahead();
 
    Expression* parse_Expression(); // wyrażenie
    Expression* parse_Constant();   // liczba
    Expression* parse_Variable();   // nazwa zmiennej
    Expression* parse_Section();    // blok
    Expression* parse_Bracket()     // nawias
    Expression* parse_String()      // napis
};

Expression* Parser::parse_Expression()
{
  Expression* e = parse_Constant();
  if (look_ahead() == EOS)
    return e;
  else
  {
    delete e;
    throw Not_parsed();
  }
}

Expression* Parser::parse_Constant()
{
  Expression* e = parse_Variable();
  if (look_ahead() == EOS)
    return e;
  else
  {
    delete e;
    throw Not_parsed();
  }
}

Expression* Parser::parse_Variable()
{
  Expression* e = NULL;
 //tutaj będzie sprawdzana zgodność nazwy zmiennej z ustaloną gramatyką
}


Expression* Parser::parse_Section()
{
  Expression* e = NULL;
  //sprawdź nazwę zmiennej
  //sprawdź wyrażenie
  //sprawdź, czy są kolejne nawiasy
 
}

Expression* Parser::parse_String()
{
  Expression* e = NULL;
 
  try
  {
    e = parse_mult();
    char c = look_ahead();
 
    while(c == '+' || c == '-')
    {
      position++;
      e = new Binary_operator(c, e, parse_mult());
      c = look_ahead();
    }
  }
  catch (Not_parsed)
  {
    delete e;
    throw Not_parsed();
  }
 
  return e;
}

Expression* Parser::parse_Bracket()
{
position++;

  Expression* e = parse_string();
  if (look_ahead() == ')')
  {
    position++;
    return e;
  }
  else
  {
    delete e;
    throw Not_parsed();
  }
}
